---
title: "Chapter solutions"
author: "Barry Quinn"
editor: visual
---

# Chapter 1 Statistics and Probability Primer

1.  Calculating Stock Returns:

**Objective:** To calculate the annualized return of a stock over a three-year period.

**Solution:**

```{R}
# Initial and final prices of the stock
initial_price <- 100
final_price <- 150

# Investment period in years
years <- 3

# Calculating the annualized return
annualized_return <- (final_price / initial_price)^(1/years) - 1

# Output the annualized return
print(annualized_return)
```

**Explanation:** The annualized return is calculated by finding the geometric average of the yearly return. It accounts for compounding over the period.

2.  Descriptive Statistics of Financial Data:

**Objective:** To summarize and interpret a dataset of stock prices.

**Solution:**

```{R}
# Dataset of stock prices
stock_prices <- c(120, 125, 130, 128, 135)

# Summary statistics
summary_stats <- summary(stock_prices)

# Output the summary statistics
print(summary_stats)
```

**Explanation:** `summary()` function in R provides a quick statistical summary of the data, including measures like minimum, first quartile, median, mean, third quartile, and maximum.

3.  Basic Risk Assessment:

**Objective:** To calculate and interpret the standard deviation of stock returns as a measure of risk.

**Solution:**

```{R}
# Returns of a stock
stock_returns <- c(0.05, 0.02, -0.03, 0.04, 0.01)

# Calculating standard deviation
risk_measure <- sd(stock_returns)

# Output the standard deviation
print(risk_measure)
```

**Explanation:** The standard deviation provides a measure of the dispersion of returns. A higher standard deviation implies greater risk (volatility) in the stock's returns.

4.  Simple Probability Calculation:

**Objective:** To calculate the probability of an event in a financial context, exemplified by a coin toss.

**Solution:**

```{R}
# Probability of getting heads in a fair coin toss
probability_heads <- 1 / 2

# Output the probability
print(probability_heads)
```

**Explanation:** This is a basic example of classical probability, where each outcome (heads or tails) is equally likely.

5.  Basic Time Series Forecasting:

**Objective:** To use a simple moving average for forecasting the next data point in a financial time series.

**Solution:**

```{R}
# Historical stock prices
stock_prices <- c(120, 122, 121, 123, 125)

# Forecast using a simple moving average of the last 3 prices
forecast_price <- mean(tail(stock_prices, n=3))

# Output the forecasted price
print(forecast_price)
```

**Explanation:** This method forecasts the next data point by calculating the average of a specified number of the most recent data points (here, the last three prices).

6.  Advanced Risk Modeling (VaR):

**Objective:** To calculate and interpret the Value at Risk (VaR) for a portfolio.

**Solution:**

```{R}
# Historical returns of a portfolio
portfolio_returns <- c(-0.05, 0.1, 0.03, -0.02, 0.04)

# Confidence level (e.g., 95%)
alpha <- 0.05

# Calculating VaR
VaR <- quantile(portfolio_returns, alpha)

# Output the VaR
print(VaR)
```

**Explanation:** VaR measures the maximum expected loss over a given period under normal market conditions at a specified confidence level (here, 95%).

7.  Bayesian Update in Stock Forecasting:\*\*

**Objective:** To perform a Bayesian update for a stock price prediction.

**Solution:**

```{R}
# Uniform prior distribution
prior <- dbeta(1, 2, 1)

# Binomial likelihood based on new evidence (e.g., 6 increases in 10 periods)
likelihood <- dbinom(6, size=10, prob=0.5)

# Calculating the posterior distribution
posterior <- prior * likelihood

# Output the posterior probability
print(posterior)
```

**Explanation:** Bayesian update combines prior belief (uniform distribution in this case) with new evidence (likelihood) to revise the belief about a stock's price movement.

8.  Hypothesis Testing in Financial Returns:\*\*

**Objective:** To conduct and interpret a hypothesis test comparing a new investment strategy to market returns.

**Solution:**

```{R}
# Returns from a new investment strategy
strategy_returns <- c(0.07, 0.08, 0.09, 0.06, 0.1)

# Market average returns for comparison
market_returns <- c(0.05, 0.05, 0.05, 0.05, 0.05)

# Performing a t-test
t_test_result <- t.test(strategy_returns, market_returns)

# Output the t-test results
print(t_test_result)
```

**Explanation:** The t-test assesses whether the mean returns of the new strategy are significantly different from the market average. The p-value indicates the probability of observing such a difference if there were no real difference.

9.  Complex Time Series Analysis:

**Objective:** To fit an ARIMA model to a financial time series and forecast future values.

**Solution:**

```{R}
# Assuming stock_prices is a time series object
# Install and load the forecast package
library(forecast)

# Fitting an ARIMA model
arima_model <- auto.arima(stock_prices)

# Forecasting the next value
forecast_result <- forecast(arima_model, h=1)

# Output the forecast
print(forecast_result)
```

**Explanation:** `auto.arima()` function automatically selects the best ARIMA model for the time series data. The `forecast()` function then uses this model to predict future values (here, the forecast horizon is 1).

10. Portfolio Optimization:

The Markowitz model involves optimizing a portfolio by finding the best combination of assets that minimizes risk (variance) for a given expected return, or maximizes return for a given level of risk. This is achieved by adjusting the weights of each asset in the portfolio.

Certainly! Here's the solution and interpretation organized into two distinct sections:

### Solution

```{R}
# Load the quadprog library for quadratic programming
library(quadprog)

# Generate a sequence of 10 dates, one day apart
N = 10
start_date <- as.Date("2023-01-01")
dates <- seq.Date(from = start_date, by = "day", length.out = N)

# Define the historical returns for four assets
historical_returns <- data.frame("Asset1"=rnorm(N, mean = 0.04),
                                 "Asset2"=rnorm(N, mean = 0.03),
                                 "Asset3"=rnorm(N, mean = 0.09),
                                 "Asset4"=rnorm(N, mean = 0.01))
rownames(historical_returns) <- dates

# Calculate the covariance matrix of returns
Dmat <- cov(historical_returns)

# Define dvec as zero for minimum variance portfolio
dvec <- rep(0, ncol(historical_returns))

# Define the constraints (sum of weights = 1)
# Amat needs to have as many rows as there are assets plus one for the sum constraint
Amat <- cbind(1, diag(ncol(historical_returns)))
bvec <- c(1, rep(0, ncol(historical_returns)))
# Specify and solve the optimization problem

sol <- solve.QP(Dmat, dvec, Amat, bvec, meq = 1)

# Extract the optimal weights
optimal_weights <- sol$solution

# Print the optimal weights
print(optimal_weights)
```

### Interpretation

1.  **Setting Up the Data**:
    -   The code first sets up a simulated historical return data for four assets over ten days. This is necessary as the Markowitz model requires historical return data to calculate asset weights.
2.  **Covariance Matrix**:
    -   `Dmat` is calculated as the covariance matrix of the asset returns. It represents the risk relationships between each pair of assets, crucial in determining how asset prices move relative to each other.
3.  **Defining Optimization Parameters**:
    -   The vector `dvec` is set to zero since the goal is to minimize variance without targeting a specific return.
    -   `Amat` combines an equality constraint (that the sum of the asset weights equals 1) with non-negativity constraints (each asset weight must be zero or positive).
4.  **Quadratic Programming Problem**:
    -   The `solve.QP` function is used to solve the quadratic programming problem. It aims to find the asset weights that minimize the overall portfolio variance subject to the given constraints.
5.  **Optimal Weights**:
    -   The solution `sol$solution` provides the optimal weights for each asset. These weights represent how much of the portfolio should be allocated to each asset to achieve minimum risk.
6.  **Result**:
    -   The output is a set of portfolio weights that minimize the portfolio's variance (risk), considering the historical return covariance of the assets and the constraints (total weight equals 1, non-negative weights). This represents the most risk-efficient allocation of assets in the portfolio under the given conditions.

::: callout-important
These solutions provide a mix of conceptual explanations and practical R code, offering a comprehensive understanding of each question's objective and methodology.
:::
